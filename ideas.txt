generational garbage collection
  if there is no mutation, then memory changes only
    come from adding/removing roots
    any

  if there is mutation, then each mutated value


let M be a directional graph of nodes m_i and R = { r_i } subset M.
let R* be the transitive closure of R.

A node m in M is reachable if there is a path P { p_i } in M of length n  where there exists
r in R st r = p_0, p_k -> p_k+1 for 0 <= k < n, and p_n = m.

keep inverse index
on mutation, mark former target pending
scan pending for inbound using inverse index
  remove source links from inverse index
  if not present, mark children pending
  mark free

keep refindex in blockstore
pair memory lifecycle
  cons:
    get from head of free list
    insert refs to ref list

  vector-set! set-cdr! set-car! -> erase entry in index

  begin sweep
    assign i0 -> i1, i1 -> i2, etc, then sort ref list -> i0,
    init iterators

  sweep step
    check pair flags of each item, etc, searching i0, i1, ...

  end sweep
    if len(i0) > len(i1)/log2(len(i1), merge i0 into i1

pair memory page
  freelist is lowest cell
  init
    for each pair below the last, set car to #null, cdr to next pair

  => alloc-pair
    loop $again
      get active page

      while freelist empty? and smudges
        check reachable for each smudged flag group

      if freelist empty?
        => page is full
        activate next page
        br $again

      else
        new cell <- cdr freelist
        set-cdr! freelist cdr freelist
        set-car! new-cell #null
        set-cdr! new-cell #null
        decr free count
        do index maintenance
        new-cell

index
  actions
    init index
    init page
      idx = mem page + 2048
      addr = idx page
      write idx to addr
      write null to addr+4
      if i%32 != 0
        addr += 8
      idx += 8
    insert entry (idx, tgt)
      bsearch
      search outward bidirectionally for entry with tgt == null (prefer high addr on tie)
      move block, set new entry
      track # of entries moved in ema
    remove entry
      bsearch
      set
    lookup entries by idx
      bsearch, return 1st index
    begin relocation
    relocation step
    end relocation
    begin expansion
    expansion step
    end expansion

  aux fns
    bsearch
      note, lexicographic, 8 byte, in 4 byte words
    update ema
      normal is ema_n = ((k-1)ema_n-1 + v)/k
      for k = 2^n for some n, then mul-shift works
        say (15*e + v ) >> 4 or (32*e +v) >> 5
      for #s typically less than 16, use << 4 to provide fractions


  odd cases:
    expansion triggered during relocation
    relocation triggered during expansion

  worst case index to storage is 2:1 where all pairs refer to other pairs, but
  typical usage is closer to 1:1. By default, there will be 32/31 index entries
  per pair.

  allocate 1 index page per memory page, keep index pages contiguous
  and above all memory pages

  keep one empty page above the last allocated memory page, to allow
  incremental copying of index to higher memory. => copy N+1 index entries
  per allocation, where N is the number of memory pages

  initialize a full 64kb page with empty 8 byte entries evenly spaced with
  keys between the lowest cell and highest cells in a new memory page,
  i.e page + 2048 to page + 65528, aligned to 8 bytes. an empty entry has
  $null = (0xffffffff) in the second 4 bytes

  when activating a new memory page, schedule an insertion of new block of f
  empty entries into the index.

  a sorted array of pairs with a semi-dense set of gaps, avg 1 gap per k entries
  gaps have the index of the entry below, but an empty value

  operations
    lookup O(log n) -- binary search
    delete O(log n) -- find by binary search, leave entry, but set value empty
    insert O(log n) + O(k) where k is the gap radius -- find by binary search,
      find nearest gap by linear search (bidirectional, outward), shift
      entries to move gap to desired location, set value
    expand O(n) -- copies array to new array, inserting a gap every k entries

  attributes
    k, n
    filled entries
    base addr
    capacity threshold
    EMA threshold
    state (stable/expanding)
    when expanding
      new addr
      i -- index into old of next item to copy to new
      j -- index into new of next item from old

    stats
      EMA of shift radius per insert
      ratio filled/capacity

  when EMA or ratio gets above threshold
    increase size of table by 2/k
    inserting a gap for every k/2 entries

history of page types
0, mem, *, idx
0, mem, mem, *, idx, idx

explore:
  flags page holds pending/reachable flags for 32 64kb pages (2MB).

initial memory layout

0x00000000 256 bytes system state
0x00000100 256 bytes smudge bits
0x00000200 pair flags for 512KB - 16KB -> 16k - 512 bytes
0x00004000 pair memory
0x00010000 beginning of index memory
0x00020000 beginning of block store
0x00030000 end of block store/memory top

1 smudge bit covers 64 bits of pair flags
2 bits of pair flags covers 1 pair (8 bytes)

=> 1 smudge bit covers 256 bytes memory
=> 1 smudge byte covers 2KB memory
=> 32 bytes smudge covers 64 KB

64 KB requires 2KB pair flags
=> lower 2KB of pair area is covered by flags
=> lower 256 pairs are not available
=> lower 512 bits of pair flags are not needed
=> lower 64 bytes pair flags are not needed
=> lower 8 smudge bits not needed

also 1st 64B open below pair flags, and in there need space for 32B smudge
